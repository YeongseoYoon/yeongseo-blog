---
title: '이펙티브 타입스크립트 스터디 - 2장'
date: '2023-11-26T06:26:02.451Z'
summary: '타입스크립트란...뭘까?'
tags: ['TS']
---

# 타입스크립트의 타입 시스템

## 아이템 6. 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면 `타입스크립트 컴파일러(tsc)`와 단독으로 실행할 수 있는 `타입스크립트 서버(tsserver)` 두 가지를 실행할 수 있습니다.

편집기에서 타입스크립트 언어 서비스를 적극 활용하는 것이 좋습니다.

- 특정 시점에 타입스크립트가 값의 타입을 어떻게 이해하고 있는가?
- 타입스트립트가 객체 내 타입을 어떻게 추론하고 있는가?
- 등등등...

또한 언어 서비스는 라이브러리와 라이브러리의 타입 선언을 탐색할 때 도움이 됩니다.

만약 `fetch` 함수를 알아보길 원한다고 할때 Go to Definition 기능을 이용하면, 타입스크립트에 포함되어 있는 `lib.dom.d.ts`로 이동합니다.

이를 통해 타입스크립트가 동작을 어떻게 모델링하는지 알 수 있습니다.

## 아이템 7. 타입이 값들의 집합이라고 생각하기

런타임에 모든 변수는 자바스크립트 세상의 값으로부터 정해지는 각자의 고유한 값을 가집니다. 그러나 코드가 실행되기 전, 즉 타입스크립트가 오류를 체크하는 순간에는 `타입`을 가지고 있습니다.
`할당 가능한 값들의 집합`이 타입이라고 생각하면 됩니다.

가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, 타입스크립트에서는 `never`타입입니다.

그 다음으로 작은 집합은 한 가지 값만 포함하는 타입입니다. 유닛 타입이라고도 불리는 `리터럴`타입입니다. 두 개 혹은 세 개로 묶으려면 `유니온`타입을 사용합니다.

다양한 타입스크립트 오류에서 `할당 가능한`이라는 문구를 볼 수 있습니다. 이 문구는 집합의 관점에서 `~의 완소`또는 `~의 부분 집합`을 의미합니다.

집합의 관점에서, 타입 체커의 주요 역할은 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것이라고 볼 수 있습니다.

```ts
interface Identified {
  id: string;
}
```

위와 같은 타입이 있다고 할때, 어떤 객체가 string으로 할당 가능한 id 속성을 가지고 있다면 그 객체는 Identified 타입입니다. 이렇듯, 구조적 타이핑 규칙들은 어떠한 값이 다른 속성도 가질 수 있음을 의미합니다.

```ts
interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death?: Date;
}

type PersonSpan = Person & Lifespan;
```

`& 연산자`은 두 타입의 인터섹션을 계산합니다. 두 인터페이스는 공통으로 가지는 속성이 없어 PersonSpan을 never타입으로 예상할 수 있지만, 타입 연산자는 인터페이스의 속성이 아니라 값의 집합에 적용됩니다.
그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속하기 때문에, Person과 Lifespan을 둘 다 가지는 값은 인터섹션 타입에 속합니다.
인터섹션 타입의 값은 각 타입 내의 속성을 모두 포함하는 것이 일반적인 규칙입니다. 규칙이 속성에 대한 인터섹션에 관해서는 맞지만, 두 인터페이서의 유니온에 대해서는 그렇지 않습니다.

```ts
type K = keyof (Person | Lifespan); //타입이 never


keyof (A&B) = (keyof A) | (keyof B);
keyof (A|B) = (keyof A) & (keyof B);
```

타입이 집합이라는 관점에서 `extends`의 의미는 '~에 할당 가능한'과 비슷하게, '~의 부분 집합'이라는 의미로 받아들일 수 있습니다.
리터럴 타입과 유니온 타입에 비해 집합 스타일이 더 직관적으로 표현됩니다.

```ts
function getKey<K extends string>(val: any, key: K) {}
```

string을 상속한다는 의미를 객체 상속의 관점이 아닌, 집합의 관점에서 이해해야 이해가 쉽습니다. 위 제너릭 타입 K는 string의 부분 집합 범위를 가지는 어떠한 타입이 됩니다.

```ts
const list = [1, 2]; //타입은 number[]
const tuple = ([number, number] = list);
// ~~~~~'number[]'타입은 '[number,number]'타입의 0,1 속성에 없습니다.
```

number[]은 [number, number]의 부분 집합이 아니므로 할당할 수 없습니다.

타입의 값이 집합이라는 것은 동일한 값의 집합을 가지는 두 타입은 같다는 의미가 됩니다.

한편, 정수에 대한 타입, 또는 x와 y 속성 외에 다른 속성이 없는 객체는 타입스크립트 타입에 존재하지 않습니다.

## 아이템 8. 타입 공간과 값 공간의 심벌 구분하기

타입스크립트의 `심벌(Symbol)`은 타입 공간이나 값 공간 중의 한 곳에 존재합니다. `심벌`은 이름이 같더라도 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있습니다.

```ts
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({ radius, height });

function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius;
    // ~ '{}' 형식에 'radius' 속성이 없습니다.
  }
}
```

위에서 `instanceof`는 자바스크립트의 런타임 연산자이고 값에 대해 연산을 하기 때문에, 타입이 아니라 함수를 참조합니다.

한편 연산자 중에서도 타입에서 쓰일 때와 값에서 쓰일 때 다른 기능을 하는 것들이 있습니다. 그 중 하나로 `typeof`가 있습니다.
타입의 관점에서, `typeof`는 값을 읽어서 타입스크립트 타입을 반환합니다. 타입 공간의 `typeof`는 보다 큰 타입의 일부분으로 사용할 수 있고, type 구문으로 이름을 붙이는 용도로도 사용할 수 있습니다.

```ts
const v = typeof Cylinder; //값이 function
type T = typeof Cylinder; //타입이 typeof Cylinder(생성자 함수)

type C = InstanceType<typeof Cylinder>; //타입이 Cylinder(인스턴스)
```

`this`, `&`, `|`, `const와 as const`, `extends`, `in` 타입 공간과 값 공간에서 다른 목적으로 사용되는 키워드 들입니다.

## 아이템 9. 타입 단언보다는 타입 선언을 사용하기

```ts
interface Person {
  name: string;
}

const alice: Person = { name: 'Alice' }; //타입 선언
const bob = { name: 'Bob' } as Person; //타입 단언
```

`타입 단언`보다 `타입 선언`을 사용하는 것이 좋습니다.
`타입 선언`은 할당되는 값이 해당 인터페이스를 만족하는지 검사하는데, `타입 단언`은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것이기 때문입니다.
이는 속성을 추가할 때도 마찬가지입니다.

화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있습니다.

```ts
const people = ['alice', 'bob', 'jan'].map((name) => ({ name }));
//결과는 {name:string;}[]
```

그럴 땐 타입 단언보다는 다음과 같이 화살표 함수 안에서 타입과 함께 변수를 선언할 수 있습니다.

```ts
const people = ['alice','bob','jan'].map(name=>({
    const person :Person = {name};
    return person;
}));

//간결하게
const people = ['alice','bob','jan'].map((name):Person=>({name}));

```

`타입 단언`이 꼭 필요한 경우도 있습니다. 개발자가 타입을 타입 체커보다 더 잘 알고있는 경우입니다.

## 아이템 10. 객체 래퍼 타입 피하기

자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환합니다.
string 기본형에 charAt같은 메서드를 사용할 때, 자바스크립트는 기본형을 String 객체로 래핑하고, 메서드를 호출하고, 래핑한 객체를 버립니다.

객체 래퍼 타입의 자동 변환은 종종 당황스러운 동작을 보일 때가 있습니다.
예를 들어 어떤 속성을 기본형에 할당한다면 그 속성이 사라지는데, 실제로는 기본형 변수가 래퍼 객체로 변환된 후, 속성이 추가되고 속성이 추가된 객체는 버려져 undefined가 출력되게 됩니다.

아무튼 이 래퍼 타입들 덕분에 기본형 값이 메소드를 사용할 수 있고, 정적 메서드도 사용할 수 있습니다.

타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링합니다.

그런데, string을 매개변수로 받는 메서드에 String 객체를 전달하면 문제가 발생합니다.

string은 String에 할당할 수 있지만 String은 string에 할당할 수 없습니다. 그러므로 객체 래퍼 타입보다는 기본형 타입을 사용해야 합니다.
