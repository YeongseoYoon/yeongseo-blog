---
title: '리액트 훅을 활용한 마이크로 상태 관리 - 1장 리액트 훅을 이용한 마이크로 상태 관리'
date: '2024-08-31T01:25:05.665Z'
summary: '상태 관리...그거 어떻게 하는건데'
tags: ['REACT', 'HOOK', 'STATE']
---

# 리액트 훅을 이용한 마이크로 상태 관리

리액트 초기 상태 관리 방식은 단순했습니다. 부모 컴포넌트가 상태를 관리하고, 자식 컴포넌트에게 props로 해당 상태를 전달하는 방식이었습니다.
이 방식은 소규모 애플리케이션에서는 효과적이었지만, 애플리케이션이 커질수록 `Props 드릴링`이라는 문제점이 발생했습니다.

`Props 드릴링`은 여러 레벨의 컴포넌트를 통해 props를 전달해야 하는 상황을 의미합니다.
예를 들어, 최상위 컴포넌트에서 하위 컴포넌트까지 특정 데이터를 전달하기 위해 중간에 위치한 컴포넌트들이 그 데이터를 받아서 다시 전달해야 하는 경우가 생기는데, 이 과정이 복잡해질수록 코드가 장황해지고 관리가 어려워집니다.
특히, 데이터가 깊이 중첩된 구조에서 필요한 컴포넌트로 전달될 때, 중간에 있는 컴포넌트는 의미 없는 데이터를 전달해야 하는 경우가 발생합니다.

이런 문제를 해결하기 위해 `Flux 패턴`이 등장했습니다.
`Flux`는 Facebook에서 제안한 아키텍처 패턴으로, 리액트 애플리케이션의 데이터 흐름을 `단방향`으로 유지하는 것이 특징입니다.

`Flux`는 다음과 같은 구성 요소로 이루어져 있습니다.

> - Action: 사용자 인터페이스에서 발생하는 이벤트나 데이터 업데이트의 의도를 표현하는 객체.
> - Dispatcher: 모든 액션을 중앙에서 관리하며, 액션을 스토어에 전달하는 역할을 합니다.
> - Store: 애플리케이션의 상태를 보유하고 있으며, 특정 액션에 따라 상태를 업데이트합니다.
> - View: 리액트 컴포넌트로, 스토어의 상태를 구독하고, 상태 변경에 따라 UI를 업데이트합니다.

`Redux`는 `Flux 패턴`을 기반으로 만들어진 라이브러리로, 초기 리액트 생태계에서 전역 상태 관리의 표준으로 자리 잡았습니다.
그렇지만 `Redux`는 위에서 언급한 구성 요소를 위한 코드가 많아지고, 복잡해지는 문제점이 있었습니다. 또 일부에서는 `Props 드릴링`이 그렇게 크리티컬한 문제가 아니라는 의견도 있었습니다.

리액트 16.8 버전에서 `Hooks`가 도입되면서 상태 관리 방식이 크게 변화했습니다. `Hooks`는 함수 컴포넌트에서도 상태를 관리할 수 있게 해주는 기능으로, 상태 관리를 더욱 더 마이크로화 할 수 있게 해주었습니다.
또한 `Context API`의 개선으로 전역 상태 관리가 더욱 쉬워져 `Redux`와 같은 전역 상태 관리 라이브러리를 사용하지 않고도 전역 상태 관리를 할 수 있게 되었습니다.

`리액트 훅을 이용한 마이크로 상태 관리` 책에서는 이러한 마이크로 상태 관리에 대한 이해와 상태 관리 방법을 설명합니다.

## 마이크로 상태 관리 이해하기

리액트 훅의 등장으로 특정 목적에 따른 해결책을 제공할 수 있게 되었습니다.

- 폼 상태는 전역 상태와 별도로 처리해야하는데 이는 단일 상태로 해결할 수 없다.
- 서버 캐시 상태는 다른 상태와는 다른 리페칭 같은 고유한 특성이 있다.
- 내비게이션 상태는 원 상태가 브라우저에 있다는 특수한 요건이 있기 때문에 단일 상태는 적합하지 않다.

그렇지만 목적 지향적인 방법으로 처리할 수 없는 상태도 분명 존재하므로 범용적인 상태 관리가 필요합니다. 범용적인 상태 관리를 위한 방법은 가벼워야 하며, 개발자는 요구사항에 따라 적절한 방법을 선택할 수 있어야하는데 이를 가리켜 `마이크로 상태 관리`라고 합니다.

`마이크로 상태 관리`는 다음과 같은 작업을 수행하기 위한 기본적인 상태 관리 기능이 필요합니다.

> - 상태 읽기
> - 상태 갱신
> - 상태 기반 렌더링

기본적인 상태 관리 기능은 위와 같지만, 이에 추가적인 기능이 필요할 수 있어 마이크로 상태 관리를 사용하는 방법은 여러 방법이 존재합니다.

## 리액트 훅 사용하기

리액트 훅에는 상태 관리 방법을 구현하기 위한 `useState, useEffect, useReducer` 등 여러 기본 훅이 포함되어 있습니다. 이들을 활용해 커스텀 훅을 개발하면 다음과 같은 장점을 얻을 수 있습니다.

1. 목적에 맞춘 코드 작성으로 코드의 가독성을 높일 수 있습니다.
2. 컴포넌트를 수정하지 않고도 새로운 기능을 쉽게 추가할 수 있습니다.

결론적으로, 커스텀 훅을 사용하면 코드의 목적을 명확히 하고, 렌더링 로직과 동작을 분리하여 더 깔끔하고 유지보수하기 쉬운 코드를 작성할 수 있습니다.

### 데이터 불러오기를 위한 서스펜스와 동시성 렌더링

`데이터 불러오기를 위한 서스펜스`는 비동기 처리에 대한 걱정 없이 컴포넌트를 코딩할 수 있는 방법입니다.
또한 `동시성 렌더링`은 렌더링 프로세스를 청크라는 단위로 분할해 CPU가 장시간 차단되는 것을 방지하는 방법입니다.

기존 state나 ref를 직접 변경하거나, 함수가 여러 번 호출되더라도 순수하지 않게 동작하는 것은 리액트 훅을 사용할 때의 규칙을 위반하는 것입니다.
비동시성 렌더링에서는 위 규칙을 위반한 코드를 작성하더라도 문제 없이 작동하므로 개발자들은 잘못됐다는 것을 알아차리지 못하지만, 동시성 렌더링 혹은 서스펜스 사용 시 규칙을 위반하게 되면 문제가 발생할 수 있으므로 규칙을 잘 준수해 작성해야합니다.

## 전역 상태 탐구하기

리액트는 컴포넌트에서 정의되고 컴포넌트 트리 내에서 사용되는 상태에 대해 기본적인 훅을 제공하는데 이를 `지역 상태`라고 부릅니다.
반면 `전역 상태`는 애플리케이션에서 떨어져있는 여러 컴포넌트에서 공유되는 상태를 의미합니다. 전역 상태가 싱글턴일 필요는 없으며, 이러한 특성을 강조하기 위해 `공유 상태`라고 부르기도 합니다.

> ✏️ 싱글턴이란?
>
> 싱글턴은 클래스의 인스턴스가 오직 하나만 생성되는 것을 보장하는 패턴입니다.
> 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴합니다.
> 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용됩니다.

리액트에서 전역 상태를 구현하는 것은 간단하지 않은데, 그 이유는 리액트가 `컴포넌트 모델`에 기반하기 때문입니다.
`컴포넌트 모델`에서는 지역성이 중요하며 이는 컴포넌트가 서로 격리되어야 하고, 재사용이 가능해야함을 의미합니다. 컴포넌트가 컴포넌트 외부에 의존하는 경우 동작이 일관되지 않을 수 있으므로 재사용이 불가능할 수 있습니다.
그러므로 전역 상태에 가급적 의존하지 않는 것이 좋습니다.

## useState 사용하기

```tsx
const App = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      {count}
      <button onClick={() => setCount(1)}>Set Count on 1</button>
    </div>
  );
};
```

위 코드에서 버튼을 여러번 클릭하면 setCount(1)를 재호출하지만 동일한 값이기 때문에 `베일아웃`되어 리렌더링이 되지 않습니다.

그렇다면 다음과 같은 경우는 어떨까요?

```tsx
const App = () => {
  const [state, setState] = useState({ count: 0 });

  return (
    <div>
      {state.count}
      <button onClick={() => setState({ count: 1 })}>Set Count on 1</button>
    </div>
  );
};
```

화면상으로는 값이 계속 1로 보여지기 때문에 렌더링 되지 않는 것처럼 보여집니다. 하지만 실제로는 렌더링이 되고 있습니다.
그 이유는 리액트의 렌더링 메커니즘 때문입니다.

리액트는 setState를 호출할 때 전달된 객체와 기존 상태 객체를 `얕게 비교`합니다. 만약 두 객체가 다르다면, 리액트는 상태가 변경되었다고 판단하고 컴포넌트를 다시 렌더링합니다.
예를 들어, 위 코드에서는 `setState({ count: 1 })`가 호출되면, 새로운 객체 `{ count: 1 `}가 기존 객체와 비교됩니다. 두 객체는 서로 다른 참조를 가지기 때문에 리렌더링이 발생합니다.

```tsx
const App = () => {
  const [state, setState] = useState({ count: 0 });

  return (
    <div>
      {state.count}
      <button
        onClick={() => {
          state.count = 1;
          setState(state);
        }}
      >
        Set Count on 1
      </button>
    </div>
  );
};
```

마찬가지로 위와 같이 작성하면 state객체 내부의 값이 변경되었을 뿐 실제로는 변경되지 않았으므로 베일아웃되어 리렌더링이 되지 않습니다.

```tsx
const App = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      {count}
      <button onClick={() => setCount(count + 1)}>Set Count on {count + 1}</button>
    </div>
  );
};
```

리액트에서 상태 업데이트는 비동기적으로 동작하는 것처럼 보여지며, 성능 최적화를 위해 상태 업데이트가 배치 처리될 수 있습니다. 따라서 위 코드에서는 빠르게 버튼을 클릭하면 카운트가 한번만 증가합니다.
setCount(count + 1)이 두 번 호출될 때, React는 이를 최적화하여 하나의 상태 업데이트로 병합할 수 있습니다.

### 함수로 상태 갱신하기

리액트에서는 상태를 업데이트할 때 함수를 사용하는 것이 좋습니다. 함수를 사용하면 이전 상태를 쉽게 `참조`할 수 있기 때문입니다.

```tsx
const App = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      {count}
      <button onClick={() => setCount((prevCount) => prevCount + 1)}>
        Set Count on {count + 1}
      </button>
    </div>
  );
};
```

대부분의 경우 갱신 함수는 이전 값을 기반으로 갱신하는 경우에 유용합니다.

```tsx
const App = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount((prevCount) => prevCount + 1);
    }, 1000);

    return () => clearInterval(id);
  }, []);

  return (
    <div>
      {count}
      <button
        onClick={() => setCount((prevCount) => (prevCount % 2 === 0 ? prevCount : prevCount + 1))}
      >
        increment count if it makes the result even
      </button>
    </div>
  );
};
```

위 코드는 갱신 함수를 통한 베일아웃을 확인할 수 있는 코드입니다. 갱신 함수가 이전 상태와 동일한 상태를 반환하는 경우 베일아웃이 발생하고 컴포넌트는 리렌더링되지 않습니다.(두 번 눌리는 것을 방지)

### 지연 초기화

일반적으로 useState를 사용할 때 초기값을 직접 지정하는 방식으로 상태를 설정합니다. useState(0)처럼 초기값을 직접 전달하면, 리액트는 컴포넌트가 렌더링될 때마다 0을 초기값으로 설정합니다.

```tsx
const App = () => {
  const [count, setCount] = useState(() => 0);

  return (
    <div>
      {count}
      <button onClick={() => setCount((prevCount) => prevCount + 1)}>
        Set Count on {count + 1}
      </button>
    </div>
  );
};
```

위 예제의 경우 useState에 함수가 전달되며, 이 함수는 컴포넌트가 처음 렌더링될 때(마운트 될 때) 한 번만 호출되어 초기값을 계산합니다.
즉 함수를 전달하면, 함수가 한 번만 호출되어 초기값을 계산하므로 초기값 계산 비용이 많이 드는 경우에 효율적입니다.

이를 `지연 초기화`라고 하는데, `지연 초기화`를 사용하는 경우는 다음과 같습니다.

1. 초기값 계산이 복잡하거나 비용이 많이 드는 경우: 예를 들어, 초기값이 복잡한 계산 결과이거나, API 호출 등 무거운 작업에 의해 결정되는 경우 지연 초기화로 초기 렌더링 성능을 최적화할 수 있습니다.
2. 불필요한 연산 방지: 초기값이 함수로 전달될 경우, 그 함수는 컴포넌트가 처음 렌더링될 때 한 번만 호출되므로 불필요한 연산이 줄어듭니다. useState는 함수 자체를 받기 때문에 해당 함수가 반환하는 값으로 초기값을 설정합니다.

## useReducer 사용하기

### 기본 사용법

useReducer를 사용하면 미리 정의된 리듀서 함수와 초기 상태를 매개변수로 받아 리듀서 함수를 정의할 수 있습니다. 리듀서 함수는 순수 함수기 때문에 테스트가 용이합니다.

```tsx
type ActionType = { type: 'INCREMENT' } | { type: 'SET_TEXT'; text: string };

const reducer = (state: { count: number; text: string }, action: ActionType) => {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'SET_TEXT':
      return { ...state, text: action.text };
    default:
      return state;
  }
};

const App = () => {
  const [state, dispatch] = useReducer(reducer, { count: 0, text: 'hi' });

  console.log('App component re-rendered');

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
      <input
        value={state.text}
        onChange={(e) => dispatch({ type: 'SET_TEXT', text: e.target.value })}
      />
    </div>
  );
};
```

### 베일아웃

`베일아웃`은 useReducer에서도 작동합니다.

```tsx
type ActionType = { type: 'INCREMENT' } | { type: 'SET_TEXT'; text: string };

const reducer = (state: { count: number; text: string }, action: ActionType) => {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'SET_TEXT':
      if (!action.text) return state;
      return { ...state, text: action.text };
    default:
      return state;
  }
};

const App = () => {
  const [state, dispatch] = useReducer(reducer, { count: 0, text: 'hi' });

  console.log('App component re-rendered');

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>
      <input
        value={state.text}
        onChange={(e) => dispatch({ type: 'SET_TEXT', text: e.target.value })}
      />
    </div>
  );
};
```

위 코드처럼 state 자체를 반환하면 `베일아웃`이 발생합니다. 이는 리액트가 상태가 변경되지 않았다고 판단하기 때문입니다.

### 원시 값

useReducer 훅은 상태를 객체뿐만 아니라 숫자, 문자열, 불리언 등의 원시 값으로도 관리할 수 있습니다. 액션 객체에도 반드시 객체 형태로 데이터를 담을 필요가 없습니다.

### 지연 초기화

useReducer도 초기값을 `지연 초기화`할 수 있습니다.
useReducer는 지연 초기화를 위해 세 번째 옵셔널 매개변수를 받을 수 있는데, 이때 지연 초기화 함수는 useReducer의 두 번째 인수를 받습니다.

## useState와 useReducer의 유사점과 차이점

useReducer를 이용해 useState를 구현할 수 있고, useState를 이용해 useReducer를 구현할 수 있습니다.
그렇지만 useReducer로 useState를 만들때는 미묘한 차이가 있습니다.

### 초기화 함수 사용하기

reducer와 init을 훅이나 컴포넌트 외부에서 정의할 수 있다는 점입니다. 이는 useReducer에서만 가능하고 useState에서는 불가능합니다.

### 인라인 리듀서 사용하기

인라인 리듀서 함수는 외부 변수에 의존할 수 있습니다. 이는 useReducer에서만 가능하고 useState에서는 불가능합니다.

```tsx
const useScore = (bonus) => useReducer((prev, delta) => prev + delta + bonus, 0);
```

위 코드는 delta와 bonus가 모두 갱신된 경우에도 올바르게 동작합니다. useState의 경우 이전 렌더링에서의 이전 bonus 값만을 사용합니다.
위 코드가 가능한 이유는 useReducer가 렌더링 단계에서 리듀서 함수를 호출하기 때문입니다.

### ✏️ 출처

https://f-lab.kr/insight/react-state-management-evolution
https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94#mvvm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90---angular-react-vue
https://ko.wikipedia.org/wiki/%EC%8B%B1%EA%B8%80%ED%84%B4_%ED%8C%A8%ED%84%B4
