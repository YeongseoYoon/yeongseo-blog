---
title: '타입스크립트 고군분투기'
date: '2024-02-02T12:29:37.312Z'
summary: '졌잘싸(졌지만 잘 싸웠다)'
tags: ['TS']
---

최근에 회사에서 이슈를 해결해야하는 일이 있었습니다.
체크박스 컴포넌트를 다루는데, 이때 체크박스를 리스트 렌더링시에 map의 콜백함수 두번째 인자인 index를 사용하여 체크박스의 토글 상태를 제어하고 있었습니다.
한 페이지에서만 체크박스를 토글하는 문제라면 상관이 없었는데, 다른 페이지를 가게 되었을때도 같은 인덱스에 체크된 상태가 남아있어 사용자가 의도하지 않은 체크박스에도 체크가 되는 문제가 발생하고 있었습니다.

리스트 렌더링중 체크박스의 상태가 잘못 제어되고있는 이슈가 있었다. 그 이유는 체크박스 토글 상태를 변경할수있는 함수의 반환값이 Array 고차함수의 콜백함수 두번째 인자인 index로 관리되고있어 문제가 됐었다. 그래서 이펙티브 타입스크립트에서 배웠던 내용을 적용하여 이 이슈를 해결해보고자 했다.

체크박스를 제어할수있는 훅의 형태는 아래의 형태였다.

```tsx
const Table = () => {
  const 데이터목록 = use데이터호출();
  const [전체_선택여부, 전체_선택여부_제어] = useState(false);

  const { 선택된_체크박스, 전체_토글하기 } = use체크박스_제어<데이터타입>();

  const 전체_토글하기_핸들러 = () => {
    전체_토글하기(전체_선택여부, 데이터목록); // 이 부분에 주목
  };

  return (
    <table>
      <CheckBox
        onClick={전체_토글하기_핸들러}
        onChange={(e) => 전체_선택여부_제어(e.target.checked)}
      />
      {데이터목록.map((데이터) => (
        <CheckBox onClick={() => 체크박스_선택()}>{데이터.보여줄내용}</CheckBox>
      ))}
    </table>
  );
};

export const use체크박스_제어 = <T extends any>() => {
  const [선택된_체크박스, 선택된_체크박스_제어] = useState<{ [key: number]: T }>({});

  const 전체_토글하기 = (체크되었는가: boolean, 데이터목록: T[]) => {
    선택된_체크박스_제어(() => {
      if (!체크되었는가) return {};

      return 데이터목록.reduce<{ [key: number]: T }>((누적, 현재_데이터, 인덱스) => {
        return { ...누적, [인덱스]: 현재_데이터 }; // 인덱스가 체크박스 선택여부에 영향을 주는것에 주목
      }, {});
    });
  };

  return {
    // 다른 상태, 함수 반환
    선택된_체크박스,
    전체_토글하기,
  };
};
```

이런 형식인 커스텀 훅스였고 Table 컴포넌트에서 사용되고있다. 주석으로 주목하라는것에 주목해보자.

```tsx
// 이벤트 핸들러
const 전체_토글하기_핸들러 = () => {
  전체_토글하기(전체_선택여부, 데이터목록); // 이 부분에 주목
};

// 체크박스 상태 변경 함수
const 전체_토글하기 = (체크되었는가: boolean, 데이터목록: T[]) => {
  선택된_체크박스_제어(() => {
    if (!체크되었는가) return {};

    return 데이터목록.reduce<{ [key: number]: T }>((누적, 현재_데이터, 인덱스) => {
      return { ...누적, [인덱스]: 현재_데이터 }; // 인덱스가 체크박스 선택여부에 영향을 주는것에 주목
    }, {});
  });
};
```
